# -*- coding: utf-8 -*-
"""CNN_SciptOpt_RS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p0ctTx0cYOZRCL3mf2nLLenk6YM-j4Js
"""

# Quadratic objective with double initialization.

from functools import reduce
from itertools import combinations as Nchoosek

import numpy as np
# import cvxpy as cp
from scipy.optimize import LinearConstraint, NonlinearConstraint, minimize, BFGS

# import cvxpy.atoms.affine.transpose as Transpose
# from cvxpy.atoms import multiply,sum,min,abs,power
# from cvxpy.atoms.affine import hstack,vstack
# import cvxpy.atoms.norm as Norm
from numpy import pi
from numpy.random import exponential,uniform
# from itertools import combinations as Nchoosek
from collections import deque

def Norm_Square(X):
    return np.sum(np.square(np.abs(X)))



class MIMO_BS:
    def __init__(self, L, K, N, M, P, S, SNR, MAC_No): # L: Number of Users, K: Number of Users, N: No of Files, M: Cache Size
        self.L=L #No of Antenna
        self.K=K #No of Users
        # self.K_Group=np.ceil(self.K/2).astype(int)
        self.N=N #No of Files
        self.S=S # No. of streams
        self.Dynamic_S=S
        self.M=M #Cache Size
        self.P=P #Power Constraint
        self.CSIT=np.zeros((L,K))
        self.MeanFade=1.0
        self.PrecodingVector=np.zeros((L,S))
        self.Rates=np.zeros((K,))
        self.IntendedUsers=np.eye(L,K)
        self.SINRVec=np.zeros((K,L+1))
        self.Noise=1
        self.SNR=SNR
        self.MaxStreams=MAC_No
        self.Combination=deque()
        self.Permute()
        for i in range(0,self.Combination.__len__()):
            print(self.Combination[i])
        self.SMatrix = self.CSIT * self.IntendedUsers
        self.IMatrix = self.CSIT * (1 - self.IntendedUsers)
        self.QueueFirst = deque([])
        self.QueueSecond = deque([])
        self.QueueThird = deque([])
        self.QueueFourth = deque([])
        self.Union = []
        self.Groups = []
        # self.K_Group_vec=np.arange(0,self.K)

        self.K_Group=np.zeros((1,self.S))
        self.CSIT_Full=np.array([],dtype=complex)

        self.K_Group_vec=-1*np.ones((self.S,self.K))
        self.min_sum=1
        # self.badSNRloss_dB=15 # Loss in dB for Bad users
        self.badSNRloss_dB=0 # Loss in dB for Bad users

        self.Loss=10**(-self.badSNRloss_dB/10)


    def PrepVar(self):
        self.K_Group=np.zeros((self.Dynamic_S,)).astype(int)
        self.K_Group_vec=-1*np.ones((self.Dynamic_S,self.K)).astype(int)

    def Permute(self):
        for DS in range(1, self.S+1):
            Combination = deque()

            for k in range(1,DS+1):
                Combination.append(np.array(list(Nchoosek(np.arange(0, DS), k))))
            self.Combination.append(Combination)

    def FormGroups(self):
        Group_Union = reduce(np.union1d, tuple(self.K_Group_vec))
        neg_ind=np.argwhere(Group_Union<0)
        Group_Union=np.delete(Group_Union,neg_ind)
        # print(len(Group_Union))
        groups = np.zeros((self.Dynamic_S, len(Group_Union)))
        for u in range(0,len(Group_Union)):

            for uin in range(0, self.Dynamic_S):
                check_group=self.K_Group_vec[uin, 0:self.K_Group[uin]]
                if reduce(np.logical_or,(np.isin(check_group, Group_Union[u],assume_unique=True))):
                    groups[uin, u] = 1
        self.Union=Group_Union
        self.Groups=groups




    def GetCSITAsym(self,goodUsers):
        CSIT_Full = np.sqrt(exponential(1 / self.MeanFade, (self.L, self.K))) * np.exp(1j * uniform(0, 2 * pi, (self.L, self.K)))
        CSIT_Full[:,goodUsers:self.K]=np.sqrt(self.Loss)*CSIT_Full[:,goodUsers:self.K]
        self.CSIT_Full=CSIT_Full
        self.CSIT=CSIT_Full[:,self.Union]
        global h_complex
        h_complex=CSIT_Full
        #print("H values complex")
        #print(h_complex)
        global h_real
        h_real=self.complex_to_real(CSIT_Full)
        h_real=h_real[0:16]
        #("H values real")
        #print(h_real)
        return CSIT_Full, h_real

        # for i in range(0, self.Dynamic_S):
        #     self.CSIT.append(CSIT_Full[:, self.K_Group_vec[i, 0:self.K_Group[i]]])

    def GetCSIT(self):
        self.CSIT=deque()
        CSIT_Full=np.sqrt(exponential(1/self.MeanFade,(self.L,self.K))*np.exp(1j*uniform(0,2*pi,(self.L,self.K))))
        for i in range(0,self.Dynamic_S):
            self.CSIT=CSIT_Full[:,self.K_Group_vec[i,0:self.K_Group[i]]]
        # self.SMatrix = self.CSIT * self.IntendedUsers
        # self.IMatrix = self.CSIT * (1 - self.IntendedUsers)

    def real_to_complex(self,z):  # real vector of length 2n -> complex of length n
        return z[:len(z) // 2] + 1j * z[len(z) // 2:]

    def complex_to_real(self,z):  # complex vector of length n -> real of length 2n
        return np.concatenate((np.real(z), np.imag(z)))
    def SNRObjective(self,W,min_sum=1):
        W=self.real_to_complex(W)
        R=np.square(np.abs(np.matmul(np.transpose(W),self.CSIT[:,0:self.K_Group])))
        return -np.min(R)



    def RateCalc(self,W):
        W = np.reshape(W, (2 * self.L, self.Dynamic_S))
        Wt = 1j * np.ones((self.L, self.Dynamic_S))
        for i in range(0, self.Dynamic_S):
            Wt[:, i] = self.real_to_complex(W[:, i])
            # Powers[i,0:self.K_Group[i]]=np.square(np.abs(np.matmul(np.transpose(Wt[:,i]), self.CSIT[i][:, 0:self.K_Group[i]])))
        W = Wt
        Powers = np.square(np.abs(np.matmul(np.transpose(W), self.CSIT)))
        SignalPower = np.multiply(Powers, self.Groups)
        InterferPower = np.sum(np.multiply(Powers, 1 - self.Groups), axis=0)

        commons = np.sum(self.Groups, axis=0).astype(int)
        Rates = np.array([])
        for c in range(0, len(commons)):
            vec = SignalPower[np.argwhere(SignalPower[:, c] > 0), c]
            for comb in range(0, commons[c]):
                CombVecInd = self.Combination[commons[c] - 1][comb][0]
                Sig_Combinations = vec[CombVecInd]
                Rates = np.append(Rates, (1 / (comb + 1)) * np.log2(
                    1 + np.sum(Sig_Combinations, axis=1) / (self.Noise + InterferPower[c])))
        return Rates



    def RateObjective(self,W):
        W=np.reshape(W,(2*self.L,self.Dynamic_S))
        Wt=1j*np.ones((self.L,self.Dynamic_S))
        for i in range(0,self.Dynamic_S):
            Wt[:,i]=self.real_to_complex(W[:,i])
            # Powers[i,0:self.K_Group[i]]=np.square(np.abs(np.matmul(np.transpose(Wt[:,i]), self.CSIT[i][:, 0:self.K_Group[i]])))
        W=Wt
        Powers=np.square(np.abs(np.matmul(np.transpose(W), self.CSIT)))
        SignalPower=np.multiply(Powers,self.Groups)
        InterferPower=np.sum(np.multiply(Powers, 1-self.Groups),axis=0)

        commons = np.sum(self.Groups,axis=0).astype(int)
        Rates=np.array([])
        for c in range(0,len(commons)):
            vec=SignalPower[np.argwhere(SignalPower[:,c]>0),c]
            for comb in range(0,commons[c]):
                CombVecInd=self.Combination[commons[c]-1][comb][0]
                Sig_Combinations=vec[CombVecInd]
                # Rates=np.append(Rates,(1/(comb+1))*np.log2(1+np.sum(Sig_Combinations,axis=1)/(self.Noise+InterferPower[c])))
                Rates = np.append(Rates, (1 + np.sum(Sig_Combinations, axis=1) / (self.Noise + InterferPower[c]))**(1 / (comb + 1)))
        return -np.min(Rates)

    def RateConstraintsRHS(self,W):
        W = np.reshape(W, (2 * self.L, self.Dynamic_S))
        Wt = 1j * np.ones((self.L, self.Dynamic_S))
        for i in range(0, self.Dynamic_S):
            Wt[:, i] = self.real_to_complex(W[:, i])
            # Powers[i,0:self.K_Group[i]]=np.square(np.abs(np.matmul(np.transpose(Wt[:,i]), self.CSIT[i][:, 0:self.K_Group[i]])))
        W = Wt
        Powers = np.square(np.abs(np.matmul(np.transpose(W), self.CSIT)))
        SignalPower = np.multiply(Powers, self.Groups)
        InterferPower = np.sum(np.multiply(Powers, 1 - self.Groups), axis=0)

        commons = np.sum(self.Groups, axis=0).astype(int)
        Rates = np.array([])
        for c in range(0, len(commons)):
            vec = SignalPower[np.argwhere(SignalPower[:, c] > 0), c]
            for comb in range(1, commons[c]):
                CombVecInd = self.Combination[commons[c] - 1][comb][0]
                Sig_Combinations = vec[CombVecInd]
                Rates = np.append(Rates,np.log2(1 + np.sum(Sig_Combinations, axis=1) / (self.Noise + InterferPower[c])))
        return Rates

    def RateConstraintsLHS(self, W):
        Wor=W
        W = np.reshape(W, (2 * self.L, self.Dynamic_S))
        Wt = 1j * np.ones((self.L, self.Dynamic_S))
        for i in range(0, self.Dynamic_S):
            Wt[:, i] = self.real_to_complex(W[:, i])
            # Powers[i,0:self.K_Group[i]]=np.square(np.abs(np.matmul(np.transpose(Wt[:,i]), self.CSIT[i][:, 0:self.K_Group[i]])))
        W = Wt
        Powers = np.square(np.abs(np.matmul(np.transpose(W), self.CSIT)))
        SignalPower = np.multiply(Powers, self.Groups)
        InterferPower = np.sum(np.multiply(Powers, 1 - self.Groups), axis=0)

        commons = np.sum(self.Groups, axis=0).astype(int)
        Rates = np.array([])
        for c in range(0, len(commons)):
            vec = SignalPower[np.argwhere(SignalPower[:, c] > 0), c]
            for comb in range(1, commons[c]):
                CombVecInd = self.Combination[commons[c] - 1][comb][0]
                Sig_Combinations = vec[CombVecInd]
                Rates = np.append(Rates,np.sum(np.log2(1 + Sig_Combinations / (self.Noise + InterferPower[c])), axis=1))
        return Rates-self.RateConstraintsRHS(Wor)
        # W=self.real_to_complex(W)
        # R=np.log2(1+np.square(np.abs(np.matmul(np.transpose(W),self.CSIT[:,0:self.K_Group])))/self.Noise)
        # if self.min_sum==0:
        #     return -np.min(R)
        # elif self.min_sum==1:
        #     return -np.sum(R)
        # else:
        #     return -np.sum(np.log(R))
    def Constraints(self,W):
        return np.sum(np.square(np.abs(W)))
    def GradConstraints(self,W):
        return 2*W

    def HessConstraints(self, W,L):
        return 2*np.eye(2*self.L*self.Dynamic_S)
        # return np.sum(np.square(np.abs(W)))
    def scipy_multicast(self,streams):
        self.Dynamic_S=streams
        # csit_old=self.CSIT
        # self
        # nl_cons=NonlinearConstraint(self.Constraints,0,self.SNR,jac='2-point', hess=BFGS())
        # W0=np.sqrt(exponential(1,(self.L,))*np.exp(1j*uniform(0,2*pi,(self.L,))))
        r=deque()
        global r_min
        r_min = list ()
        p=deque()
        r1,r2=0,0

        p1,p2=np.array([]),np.array([])
        nl_cons=NonlinearConstraint(self.Constraints,0,self.SNR,jac=self.GradConstraints, hess=self.HessConstraints)
        # nl_cons=NonlinearConstraint(self.Constraints,0,self.SNR,jac='2-point',hess=BFGS())

        # nl_cons_2 = NonlinearConstraint(self.RateConstraintsLHS, -np.inf, 0, jac='2-point', hess=BFGS())
        R_value = 0
        ab = 0
        while ((R_value <= 0.01)):
            for i in range(0,1):
                W0=np.sqrt(exponential(1,(self.L,self.Dynamic_S)))*np.exp(1j*uniform(0,2*pi,(self.L,self.Dynamic_S)))
                W0=np.reshape(W0,(self.L*self.Dynamic_S,))
                W0 = np.sqrt(self.SNR / Norm_Square(W0)) * W0
                # res = minimize(self.RateObjective, self.complex_to_real(W0), method='trust-constr', constraints = [nl_cons], options = {'verbose': 0})
                res = minimize(self.RateObjective, self.complex_to_real(W0), method='SLSQP', constraints = [nl_cons], options = {'verbose': 0})
               
                # R_value=np.log2(1 + np.square(np.abs(np.matmul(np.transpose(self.real_to_complex(res.x)), self.CSIT))))
                global w_real
                global w_complex
                w_real=res.x[0:16]
                #print("real W")
                #print(w_real)
                w_complex=self.real_to_complex(res.x)
                #print("complex W")
                #print(w_complex)
                R_value=self.RateCalc(res.x)
                r.append(R_value)
                r_min.append(np.min(R_value))
                
                p.append(self.real_to_complex(res.x))
                # if i==0:
                #     r1=R_value
                #     p1=self.real_to_complex(res.x)
                # else:
                #     r2=R_value
                #     p2=self.real_to_complex(res.x)
            ind=np.argmax(r_min)
            self.Rates=r[ind]
            self.PrecodingVector=p[ind]
            if(Norm_Square(self.PrecodingVector)>self.SNR+.5):
                # print(Norm_Square(self.PrecodingVector))
                self.PrecodingVector=self.PrecodingVector*np.sqrt(self.SNR/Norm_Square(self.PrecodingVector))
                self.Rates=self.RateCalc(self.complex_to_real(self.PrecodingVector))
            R_value=np.min(self.Rates)
            #print("r_min value")
            #print(r_min)
            #print("R value")
            #print(r)
        # if np.min(r1)>=np.min(r2):
        #     self.Rates = r1
        #     self.PrecodingVector = p1
        # else:
        #     self.Rates = r2
        #     self.PrecodingVector = p2
        #print(R_value,Norm_Square(self.real_to_complex(res.x)))
        # self.Rates=R_value
        # self.PrecodingVector=self.real_to_complex(res.x)
        #return R_value,self.real_to_complex(res.x),0

N=6
import tensorflow as tf
import numpy as np

list_tensor= list() #stores all the tensors (16,6,2)
list_r=list()

MB = MIMO_BS(16, N, 100, 1, 10, 1, 10, 1)
for i in range(0,1000):
  MB.Dynamic_S = 1
  MB.PrepVar()
  service_times = np.array([])
  mean_user=N
  MB.K_Group[0] = mean_user
  MB.K_Group_vec[0, 0:mean_user] = np.arange(0, mean_user)
  MB.FormGroups()

  MB.GetCSITAsym(6)

  MB.scipy_multicast(1)
  
  w_complex=w_real.reshape(16,1)
  matrix_complex=h_complex
  matrix_complex = np.append(matrix_complex, w_complex, axis=1)
  #print(matrix_complex.shape)
  #print(h_complex.shape)
  #print(w_complex.shape)

  w_real=w_real.reshape(16,1)
  matrix_real=h_real
  matrix_real = np.append(matrix_real, w_real, axis=1)
  #print(matrix_real.shape)
  #print(h_real.shape)
  #print(w_real.shape)

  
  list_complex = list()
  list_real = list()
 
  list_complex.append(matrix_complex)
  list_real.append(matrix_real)

  list_complex.extend(list_real)
  list_complex=tf.convert_to_tensor(list_complex) #list_complex = matrix_real + matrix_complex 
  #list_complex = tf.reshape(list_complex,(16,6,2))
  service_times=np.append(service_times,1/np.min(MB.Rates))
  x=np.average(service_times)

  list_r #label
   
  list_tensor.append(list_complex)
  list_r.append(x)

a=w_real.shape
b=w_complex.shape
c=h_real.shape
d=h_complex.shape
print("shape of w_real is",a)
print("shape of w_complex is",b)
print("shape of h_real is",c)
print("shape of h_complex is",d)
#list_r

len(list_tensor)
len(list_r)
len(list_tensor[0])

#w_complex=w_real.reshape(16,1)
#matrix_complex=h_complex
#matrix_complex = np.append(matrix_complex, w_complex, axis=1)
#print(matrix_complex.shape)
#print(h_complex.shape)
#print(w_complex.shape)

#w_real=w_real.reshape(16,1)
#matrix_real=h_real
#matrix_real = np.append(matrix_real, w_real, axis=1)
#print(matrix_real.shape)
#print(h_real.shape)
#print(w_real.shape)

#import tensorflow as tf
#import numpy as np

#list_complex = list()
#list_real = list()
#list_r=list()
#list_complex.append(matrix_complex)
#list_real.append(matrix_real)
#list_r.append(r_min)

#list_complex.extend(list_real)
#tf.convert_to_tensor(list_complex) #list_complex = matrix_real + matrix_complex
#tf.reshape(list_complex,(16,6,2))
#list_r

#import pandas as pd
#df=pd.DataFrame(np.concatenate(list_complex))
#df2=pd.DataFrame(np.concatenate(list_r))
#pd.DataFrame(np.concatenate(list_real))
#list_complex.shape()

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten, Conv2D, MaxPooling2D
import pickle

import pandas as pd
import numpy as np

X_train = list_tensor[:600]
y_train = list_r[:600]

X_train= np.array(X_train)
y_train= np.array(y_train)

X_test= list_tensor[600:]
y_test= list_r[600:]

X_test= np.array(X_test)
y_test= np.array(y_test)
#X_train.shape

model=Sequential()

model.add(Conv2D(filters=64,kernel_size=(2,2),padding="same",activation="sigmoid",input_shape=(2,16,7)))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Conv2D(filters=32,kernel_size=(2,2),padding="same",activation ="sigmoid"))
model.add(MaxPooling2D(pool_size=(1,1)))
#model.add(Conv2D(filters=32,kernel_size=(2,2),padding="same",activation="relu"))
#model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Flatten())
model.add(Dense(32,activation="sigmoid"))
model.add(Dense(1,activation="sigmoid"))

model.compile(loss='MSE', optimizer='adam', metrics=['Accuracy'])

model.fit(X_train,y_train, batch_size=120, epochs=20)

results = model.evaluate(X_test, y_test, batch_size=128)
print("test loss, test acc:", results)
print("Generate a prediction")
prediction = model.predict(X_test)
#print(prediction)
print("prediction shape:", prediction.shape)

#y_test





